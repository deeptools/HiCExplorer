#!/usr/bin/env python
#-*- coding: utf-8 -*-

import argparse, sys
import numpy as np

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.cm as cm
import hicexplorer.HiCMatrix as hm
import hicexplorer.utilities
import logging
log = logging.getLogger(__name__)


def parseArguments(args=None):
    parser = argparse.ArgumentParser(description = 'Takes a list of positions '
                                     'in the hic-matrix and makes a pooled image.')

    # define the arguments
    parser.add_argument('--matrix', '-m',
                        help='path of the Hi-C matrix to plot.',
                        required=True)

    parser.add_argument('--BED',
                        help='BED file with regions to plot interactions.',
                        type=argparse.FileType('r'),
                        required=True)

    parser.add_argument('--range',
                        help='In bp with the format low_range:high_range, '
                        'for example 1000000:2000000',
                        required=True)

    parser.add_argument('--numberOfBins',
                        help='Number of  bins to include in the submatrix. The bed regions will be centered between '
                             '- half number of bins and the other half number of bins.',
                        default='51',
                        type=int)

    parser.add_argument('--transform',
                        help='type of transformation for the matrix. The options are "none",  '
                             '"total-counts", "z-score" or "obs/exp". If total counts are selected, '
                             'then the sub-matrix values are divided by the total counts for normalization. '
                             'If z-score or obs/exp are selected, then H-C matrix is converted into a '
                             'z-score or observed / expected matrix.',
                        choices=['total-counts', 'z-score', 'obs/exp', 'none'],
                        default='none')

    parser.add_argument('--avgType',
                        help='type of average to compute final matrix. Options are mean and median. Default is median.',
                        choices=['mean', 'median'],
                        default='median')

    parser.add_argument('--outFileName', '-out',
                        help='File name to save the image. ',
                        type=argparse.FileType('w'),
                        required=True)
    
    parser.add_argument('--outFilePrefixMatrix',
                        help='If this option is given, then the values underlying the final matrix will be saved to '
                        'tab-delimited tables (one per chromosome) using the indicated prefix, for example TSS_to_TSS_chrX.tab'
                        type=argparse.FileType('w'),
                        required=False)

    parser.add_argument('--diagnosticHeatmapFile',
                        help='If given, a heatmap file (per chromosome) is saved. Each row in the heatmap contains the'
                             'diagonal of each of the submatrices centered on the bed file. This file is useful to '
                             'get an idea of the values that are used for the aggregate matrix and to determine '
                             'the fraction of sub-matrices that are aggregated that may have an enrichment at the '
                             'center.',
                        type=argparse.FileType('w'),
                        required=False)

    parser.add_argument('--chromosomes', '-C',
                        help='List of chromosomes to plot',
                        nargs='+')

    parser.add_argument('--colorMap',
                        help='Color map to use for the heatmap. Available '
                        'values can be seen here: '
                        'http://matplotlib.org/examples/color/colormaps_reference.html',
                        default='RdYlBu_r')

    parser.add_argument('--plotType',
                        help='plot type',
                        choices=['2d', '3d'],
                        default='2d')

    parser.add_argument('--vMin',
                        help='vMin',
                        type=float,
                        default=None)

    parser.add_argument('--vMax',
                        help='vMax',
                        type=float,
                        default=None)

    return parser.parse_args(args)


def read_bed_per_chrom(fh):
    """
    Reads the given BED file returning
    a dictionary that contains, per each chromosome
    a list of start, end
    """
    interval = {}
    for line in fh:
        if line[0] == "#":
            continue
        fields = line.strip().split()
        if fields[0] not in interval:
            interval[fields[0]] = []

        interval[fields[0]].append((int(fields[1]), int(fields[2])))

    return interval


def main(args):
    ma = hm.hiCMatrix(args.matrix)
    ma.maskBins(ma.nan_bins)
    ma.matrix.data[np.isnan(ma.matrix.data)] = 0

    bin_size = ma.getBinSize()
    ma.maskBins(ma.nan_bins)
    ma.matrix.data = ma.matrix.data
    new_intervals = hicexplorer.utilities.enlarge_bins(ma.cut_intervals)
    ma.setCutIntervals(new_intervals)
    min_dist, max_dist = args.range.split(":")

    if args.chromosomes:
        ma.keepOnlyTheseChr(args.chromosomes)
    chrom_list = ma.chrBinBoundaries.keys()
    log.info("checking range {}-{}".format(min_dist, max_dist))
    min_dist = int(min_dist)
    max_dist = int(max_dist)
    assert min_dist < max_dist, "Error lower range larger than upper range"

    if args.transform == "z-score":
        # use zscore matrix
        log.info("Computing z-score matrix. This may take a while.\n")
        ma.convert_to_zscore_matrix(maxdepth=max_dist * 2.5, perchr=True)
    elif args.transform == "obs/exp":
        # use zscore matrix
        log.info("Computing observed vs. expected matrix. This may take a while.\n")
        ma.convert_to_obs_exp_matrix(maxdepth=max_dist * 2.5, perchr=True)

    min_dist_in_bins = int(min_dist) / bin_size
    max_dist_in_bins = int(max_dist) / bin_size

    # read and sort bedgraph.
    bed_intervals = read_bed_per_chrom(args.BED)
    M = args.numberOfBins if args.numberOfBins % 2 == 1 else args.numberOfBins + 1
    M_half = int((M - 1) / 2)
    # make a new matrix for each chromosome.
    chrom_matrix = {}
    chrom_total = {}
    chrom_diagonals = {}
    seen = {}

    center_values = []
    for chrom in chrom_list:
        chrom_matrix[chrom] = []
        chrom_total[chrom] = 1
        chrom_diagonals[chrom] = []
        seen[chrom] = set()
        over_1_5 = 0
        chrom_bin_range = ma.getChrBinRange(chrom)

        sys.stderr.write(chrom + '\n')
        # if chrom == '2R':
        #     import ipdb; ipdb.set_trace()
        if chrom not in bed_intervals:
            continue
        for start, end in bed_intervals[chrom]:
            # check all other regions that may interact with the
            # current interval at the given depth range

            bin_id = ma.getRegionBinRange(chrom, start, end)
            if bin_id is None:
                continue
            else:
                bin_id = bin_id[0]

            for start2, end2 in bed_intervals[chrom]:
                bin_id2 = ma.getRegionBinRange(chrom, start2, end2)
                if bin_id2 is None:
                    continue
                else:
                    bin_id2 = bin_id2[0]
                if bin_id2 in seen[chrom]:
                    continue
                if min_dist_in_bins <= abs(bin_id2 - bin_id) <= max_dist_in_bins:
                    idx1, idx2 = sorted([bin_id, bin_id2])
                    if (idx1, idx2) in seen[chrom]:
                        continue
                    seen[chrom].add((idx1, idx2))
                    if idx1 - M_half < chrom_bin_range[0] or \
                            idx2 + 1 + M_half > chrom_bin_range[1]:
                        continue
                    try:
                        mat_to_append = ma.matrix[idx1 - M_half:idx1 + M_half + 1, :][:, idx2 - M_half:idx2 + M_half + 1].todense().astype(float)
                    except IndexError:
                        sys.stderr.write("index error for {} {}\n".format(idx1, idx2))
                        continue
                    if mat_to_append.sum() <= 0:
                        sys.stderr.write("empty matrix for positions {} {}\n".format(idx1, idx2))
                        continue
                    # to account for the fact that submatrices
                    # close to the diagonal have more counts thatn
                    # sumatrices far from the diagonal
                    # the submatrices values are normalized using the
                    # total submatric sum.
#
                    if args.transform == 'total_counts' and mat_to_append.sum() > 0:
                        mat_to_append = mat_to_append / mat_to_append.sum()

                    chrom_total[chrom] += 1
                    chrom_matrix[chrom].append(mat_to_append)
                    chrom_diagonals[chrom].append(mat_to_append.diagonal())
                    center_values.append(ma.matrix[idx1, idx2])
                    if ma.matrix[idx1, idx2] > 1.5:
                        over_1_5 += 1
        log.info("Number of matrices with ratio over 1.5 at center {} ({:.2f})".
                 format(over_1_5, float(over_1_5) / len(chrom_matrix)))

    fig = plt.figure(figsize=(8 * len(chrom_matrix), 5.5))
    gs = gridspec.GridSpec(1, len(chrom_matrix) + 1,
                           width_ratios=[10] * len(chrom_matrix) + [0.6])
    gs.update(wspace=0.01, hspace=0)

    for idx, chrom in enumerate(chrom_list):
        # compute median values
        if args.avgType == 'median':
            _median = np.median(np.array(chrom_matrix[chrom]), axis=0)
            if _median.sum() == 0 or np.isnan(_median.sum()):
                # test if the mean matrix is not zero
                if np.mean(np.array(chrom_matrix[chrom]), axis=0).sum() != 0:
                    sys.stderr.write("The median of the matrices is zero. Consider using "
                                     "the mean instead.\n\n")
                else:
                    sys.stderr.write("Apparently no matrices could be computed. All are "
                                     "zeros or nans.\n\n")
            chrom_matrix[chrom] = _median
        else:
            chrom_matrix[chrom] = np.mean(np.array(chrom_matrix[chrom]), axis=0)

        log.info("Mean aggregate matrix values: {}".format(chrom_matrix[chrom].mean()))
        log.info("Avg. at center values. median: {}, mean: {}".format(np.median(center_values), np.mean(center_values)))

    vmin, vmax = (args.vMin, args.vMax)
    cmap = cm.get_cmap(args.colorMap)

    log.debug("vmax: {}, vmin: {}".format(vmax, vmin))
    for idx, chrom in enumerate(chrom_list):
        log.info("total pairs considered for {}: {}".format(chrom, chrom_total[chrom]))
        try:
            chrom_matrix[chrom].shape[0]
        except IndexError:
            continue
        if chrom_matrix[chrom].shape[0] == 0:
            log.info("matrix for chrom {} is empty".format(chrom))
            continue
        if args.plotType == '2d':
            ax = plt.subplot(gs[idx])
            ax.set_title(chrom)
            img = ax.imshow(chrom_matrix[chrom], aspect='equal',
                            interpolation='nearest', vmax=vmax, vmin=vmin,
                            cmap=cmap,
                            extent=[-M_half, M_half + 1, -M_half, M_half + 1])
        else:
            from mpl_toolkits.mplot3d import Axes3D
            ax = Axes3D(fig)
            ax.set_aspect('equal')
            ax.margins(0)
            X, Y = np.meshgrid(range(-M_half, M_half + 1),
                               range(-M_half, M_half + 1))
            Z = chrom_matrix[chrom].copy()

            img = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, linewidth=0, cmap=cmap,
                                  vmax=vmax, vmin=vmin, edgecolor='none')

            ax.set_zticklabels([])
            if vmax is not None and vmax is not None:
                ax.set_zlim(vmin, vmax)
                
        if args.outFilePrefixMatrix:
            output_matrix_name=("".join((args.outFilePrefixMatrix.name, "_", chrom, ".tab")))
            np.savetxt(output_matrix_name, chrom_matrix[chrom], '%0.5f', delimiter='\t')
            
    cbar_x = plt.subplot(gs[-1])
    fig.colorbar(img, cax=cbar_x)
    plt.savefig(args.outFileName.name, dpi=100, transparent=True)
    plt.close()
    
    # plot the diagonals
    # the diagonals plot is useful to see individual cases and if they had a contact in the center
    if args.diagnosticHeatmapFile:
        num_plots = len(chrom_diagonals)
        fig = plt.figure(figsize=(num_plots * 4, 20))
        from mpl_toolkits.axes_grid1 import make_axes_locatable

        for idx, (chrom_name, values) in enumerate(chrom_diagonals.iteritems()):
            idx += 1
            ax = fig.add_subplot(1, num_plots, idx)
            try:
                heatmap = np.asarray(np.vstack(values))
            except ValueError:
                continue
            # sort by the value at the center of the rows
            order = np.argsort(heatmap[:, M_half])[::-1]
            heatmap = heatmap[order, :]
            heat_fig = ax.imshow(heatmap, aspect='auto',
                                 interpolation='nearest',
                                 cmap=cmap,
                                 origin='upper')
            ax.set_title(chrom_name)
            divider = make_axes_locatable(ax)
            cax = divider.append_axes('right', size='5%', pad=0.05)
            fig.colorbar(heat_fig, cax=cax, orientation='vertical')

        file_name = args.diagnosticHeatmapFile.name
        log.info('Heatmap file saved under: {}'.format(file_name))
        plt.savefig(file_name, dpi=200)


if __name__ == "__main__":
    args = parseArguments()
    main(args)
