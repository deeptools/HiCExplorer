import argparse
import sys
import errno
import os
import math
from multiprocessing import Process, Queue
import time
import logging
log = logging.getLogger(__name__)

import numpy as np
from scipy import stats

import hicmatrix.HiCMatrix as hm
from hicexplorer import utilities
from hicexplorer._version import __version__
from .lib import Viewpoint


def parse_arguments(args=None):
    parser = argparse.ArgumentParser(add_help=False,
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description="""
chicDifferentialTest tests if two locations under consideration of the reference point have a different interaction count. For this either Fisher's test or the chi2 contingency test can be used.
The files that are accepted for this test can be created with `chicAggregateStatistic`. H0 assumes the interactions are not different. Therefore the differential interaction counts are all where H0 was rejected.


An example usage is:

`$ chicDifferentialTest --interactionFile viewpoint1_aggregated.txt  viewpoint2_aggregated.txt --alpha 0.05 --statisticTest fisher --outputFolder differentialResults`

and this will create three files: `viewpoint1_viewpoint2_aggregated_H0_accepted.txt`, `viewpoint1_viewpoint2_aggregated_H0_rejected.txt`, `viewpoint1_viewpoint2_aggregated_results.txt`

The first file contains all locations where H0 was accepted, the second file all locations where H0 was rejected and the third one all locations with the test result.



A second mode is the batch processing mode. For this you need a file containing the names of the aggregated files (generated by chicAggregateStatistic via --writeFileNamesToFile and the batch mode):

`$ chicDifferentialTest --statisticTest fisher --alpha 0.05 --interactionFile aggregatedFilesBatch.txt --interactionFileFolder aggregatedFilesFolder --batchMode --threads 20 --outputFolder differentialResults`

This will create, as in the non-batch mode, three files per aggregated file and writes the file name to the file given by `--rejectedFileNamesToFile`. This last file can be used to plot the differential interactions per viewpoint in batch mode, using chicPlotViewpoint.
"""
                                     )

    parserRequired = parser.add_argument_group('Required arguments')

    parserRequired.add_argument('--interactionFile', '-if',
                                help='path to the interaction files which should be used for the differential test.',
                                required=True,
                                nargs='+')

    parserRequired.add_argument('--alpha', '-a',
                                help='define a significance level (alpha) for accepting samples',
                                type=float,
                                required=True)

    parserOpt = parser.add_argument_group('Optional arguments')

    parserOpt.add_argument('--interactionFileFolder', '-iff',
                           help='Folder where the interaction files are stored. Applies only for batch mode'
                           ' (Default: %(default)s).',
                           required=False,
                           default='.')
    parserOpt.add_argument('--outputFolder', '-o',
                           help='Output folder of the files'
                           ' (Default: %(default)s).',
                           required=False,
                           default='differentialResults')
    parserOpt.add_argument('--statisticTest',
                           help='Type of test used: fisher\'s exact test or chi2 contingency'
                           ' (Default: %(default)s).',
                           choices=['fisher', 'chi2'],
                           default='fisher')
    parserOpt.add_argument('--batchMode', '-bm',
                           help='turn on batch mode. The given file for --interactionFile and or --targetFile contain a list of the to be processed files.',
                           required=False,
                           action='store_true')
    parserOpt.add_argument('--threads', '-t',
                           help='Number of threads (uses the python multiprocessing module)'
                           ' (Default: %(default)s).',
                           required=False,
                           default=4,
                           type=int
                           )
    parserOpt.add_argument('--rejectedFileNamesToFile', '-r',
                           help='Writes the names of the rejected H0 (therefore containing the differential interactions) to file. Can be used for batch processing mode of chicPlotViewpoint.'
                           ' (Default: %(default)s).',
                           default='rejected_H0.txt')
    parserOpt.add_argument("--help", "-h", action="help",
                           help="show this help message and exit")
    parserOpt.add_argument('--version', action='version',
                           version='%(prog)s {}'.format(__version__))
    return parser


def readInteractionFile(pInteractionFile):

    line_content = []
    data = []

    with open(pInteractionFile, 'r') as file:
        file.readline()
        header = file.readline()
        sum_of_all_interactions = float(
            header.strip().split('\t')[-1].split(' ')[-1])
        header += file.readline()
        for line in file.readlines():
            if line.startswith('#'):
                continue
            _line = line.strip().split('\t')
            if len(_line) <= 1:
                continue
            line_content.append(_line)
            data.append([sum_of_all_interactions, float(_line[-1])])

    return header, line_content, data


def chisquare_test(pDataFile1, pDataFile2, pAlpha):
    # pair of accepted/unaccepted and pvalue
    # True is rejection of H0
    # False acceptance of H0
    test_result = []
    accepted = []
    rejected = []
    # Find the critical value for alpha confidence level
    critical_value = stats.chi2.ppf(q=1 - pAlpha, df=1)
    zero_values_counter = 0
    for i, (group1, group2) in enumerate(zip(pDataFile1, pDataFile2)):
        try:
            chi2, p_value, dof, ex = stats.chi2_contingency(
                [group1, group2], correction=False)
            if chi2 >= critical_value:
                test_result.append(p_value)
                rejected.append([i, p_value])
            else:
                test_result.append(p_value)
                accepted.append([i, p_value])

        except ValueError:
            zero_values_counter += 1
            test_result.append(np.nan)
            accepted.append([i, 1.0])

    if zero_values_counter > 0:
        log.info('{} samples were not tested because at least one condition contained no data in both groups.'.format(
            zero_values_counter))
    return test_result, accepted, rejected


def fisher_exact_test(pDataFile1, pDataFile2, pAlpha):

    test_result = []
    accepted = []
    rejected = []
    for i, (group1, group2) in enumerate(zip(pDataFile1, pDataFile2)):
        try:
            odds, p_value = stats.fisher_exact(np.ceil([group1, group2]))
            if p_value <= pAlpha:
                test_result.append(p_value)
                rejected.append([i, p_value])
            else:
                test_result.append(p_value)
                accepted.append([i, p_value])
        except ValueError:
            test_result.append(np.nan)
            accepted.append([i, 1.0])
    return test_result, accepted, rejected


def writeResult(pOutFileName, pData, pHeaderOld, pHeaderNew, pAlpha, pTest):

    with open(pOutFileName, 'w') as file:
        header = '# Differential analysis result file of HiCExplorer\'s chicDifferentialTest version '
        header += str(__version__)
        header += '\n'

        header += '# This file contains the p-values computed by {} test\n'.format(
            pTest)
        header += '# To test the smoothed (float) values they were rounded up to the next integer\n'
        header += '#\n'

        header += ' '.join(['# Alpha level', str(pAlpha)])
        header += '\n'
        header += ' '.join(['# Degrees of freedom', '1'])
        header += '\n#\n'

        file.write(header)

        file.write(pHeaderOld.split('\n')[0] + '\n')
        file.write(pHeaderNew.split('\n')[0] + '\n')

        file.write('#Chromosome\tStart\tEnd\tGene\tRelative distance\tsum of interactions 1\ttarget_1 raw\tsum of interactions 2\ttarget_2 raw\tp-value\n')

        if pData:
            for data in pData:
                line = '\t'.join(data[0][:4])
                line += '\t'

                line += '{}'.format(data[0][5])
                line += '\t'
                line += '\t'.join(format(x, '.5f') for x in data[3])
                line += '\t'

                line += '\t'.join(format(x, '.5f') for x in data[4])
                line += '\t'

                line += '\t{}\n'.format(format(data[2], '.5f'))
                file.write(line)


def run_statistical_tests(pInteractionFilesList, pArgs, pQueue=None):
    rejected_names = []
    try:
        for interactionFile in pInteractionFilesList:

            sample_prefix = interactionFile[0].split(
                '/')[-1].split('_')[0] + '_' + interactionFile[1].split('/')[-1].split('_')[0]

            region_prefix = '_'.join(
                interactionFile[0].split('/')[-1].split('_')[1:6])

            outFileName = sample_prefix + '_' + region_prefix
            rejected_name_output_file = outFileName + '_H0_rejected.txt'

            if pArgs.outputFolder != '.':
                outFileName_accepted = pArgs.outputFolder + \
                    '/' + outFileName + '_H0_accepted.txt'
                outFileName_rejected = pArgs.outputFolder + \
                    '/' + outFileName + '_H0_rejected.txt'
                outFileName = pArgs.outputFolder + '/' + outFileName + '_results.txt'
            else:
                outFileName_accepted = outFileName + '_H0_accepted.txt'
                outFileName_rejected = outFileName + '_H0_rejected.txt'
                outFileName = outFileName + '_results.txt'

            if pArgs.interactionFileFolder != '.':
                absolute_sample_path1 = pArgs.interactionFileFolder + '/' + interactionFile[0]
                absolute_sample_path2 = pArgs.interactionFileFolder + '/' + interactionFile[1]

            else:
                absolute_sample_path1 = interactionFile[0]
                absolute_sample_path2 = interactionFile[1]

            header1, line_content1, data1 = readInteractionFile(absolute_sample_path1)
            header2, line_content2, data2 = readInteractionFile(absolute_sample_path2)

            if len(line_content1) == 0 or len(line_content2) == 0:
                writeResult(outFileName, None, header1, header2,
                            pArgs.alpha, pArgs.statisticTest)
                writeResult(outFileName_accepted, None, header1, header2,
                            pArgs.alpha, pArgs.statisticTest)
                writeResult(outFileName_rejected, None, header1, header2,
                            pArgs.alpha, pArgs.statisticTest)
                rejected_names.append(rejected_name_output_file)
                continue
            if pArgs.statisticTest == 'chi2':
                test_result, accepted, rejected = chisquare_test(
                    data1, data2, pArgs.alpha)
            elif pArgs.statisticTest == 'fisher':
                test_result, accepted, rejected = fisher_exact_test(
                    data1, data2, pArgs.alpha)

            write_out_lines = []
            for i, result in enumerate(test_result):
                write_out_lines.append(
                    [line_content1[i], line_content2[i], result, data1[i], data2[i]])

            write_out_lines_accepted = []
            for result in accepted:
                write_out_lines_accepted.append(
                    [line_content1[result[0]], line_content2[result[0]], result[1], data1[result[0]], data2[result[0]]])

            write_out_lines_rejected = []
            for result in rejected:
                write_out_lines_rejected.append(
                    [line_content1[result[0]], line_content2[result[0]], result[1], data1[result[0]], data2[result[0]]])

            writeResult(outFileName, write_out_lines, header1, header2,
                        pArgs.alpha, pArgs.statisticTest)
            writeResult(outFileName_accepted, write_out_lines_accepted, header1, header2,
                        pArgs.alpha, pArgs.statisticTest)
            writeResult(outFileName_rejected, write_out_lines_rejected, header1, header2,
                        pArgs.alpha, pArgs.statisticTest)
            rejected_names.append(rejected_name_output_file)

    except Exception as exp:
        pQueue.put('Fail: ' + str(exp))
        return

    if pQueue is None:
        return
    pQueue.put(rejected_names)
    return


def main(args=None):
    args = parse_arguments().parse_args(args)
    if not os.path.exists(args.outputFolder):
        try:
            os.makedirs(args.outputFolder)
        except OSError as exc:  # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
    interactionFileList = []
    if args.batchMode:
        with open(args.interactionFile[0], 'r') as interactionFile:
            file_ = True
            while file_:
                # for line in fh.readlines():
                file_ = interactionFile.readline().strip()
                file2_ = interactionFile.readline().strip()
                if file_ != '' and file2_ != '':
                    interactionFileList.append((file_, file2_))
            log.debug('len(interactionFileList) {}'.format(len(interactionFileList)))
    else:
        if len(args.interactionFile) % 2 == 0:

            i = 0
            while i < len(args.interactionFile):
                interactionFileList.append(
                    (args.interactionFile[i], args.interactionFile[i + 1]))
                i += 2

    fail_flag = False
    fail_message = ''
    if args.batchMode:
        rejected_file_names = [None] * args.threads
        interactionFilesPerThread = len(interactionFileList) // args.threads
        all_data_collected = False
        queue = [None] * args.threads
        process = [None] * args.threads
        thread_done = [False] * args.threads
        length_of_threads = 0
        for i in range(args.threads):

            if i < args.threads - 1:
                interactionFileListThread = interactionFileList[i * interactionFilesPerThread:(i + 1) * interactionFilesPerThread]
            else:
                interactionFileListThread = interactionFileList[i * interactionFilesPerThread:]
            length_of_threads += len(interactionFileListThread)
            queue[i] = Queue()
            process[i] = Process(target=run_statistical_tests, kwargs=dict(
                pInteractionFilesList=interactionFileListThread,
                pArgs=args,
                pQueue=queue[i]
            )
            )

            process[i].start()
        log.debug('length_of_threads {}'.format(length_of_threads))
        while not all_data_collected:
            for i in range(args.threads):
                if queue[i] is not None and not queue[i].empty():
                    background_data_thread = queue[i].get()
                    if 'Fail:' in background_data_thread:
                        fail_flag = True
                        fail_message = background_data_thread[6:]
                    rejected_file_names[i] = background_data_thread
                    queue[i] = None
                    process[i].join()
                    process[i].terminate()
                    process[i] = None
                    thread_done[i] = True
            all_data_collected = True
            for thread in thread_done:
                if not thread:
                    all_data_collected = False
            time.sleep(1)
        if fail_flag:
            log.error(fail_message)
            exit(1)
    else:
        run_statistical_tests(interactionFileList, args)

    if args.batchMode:
        log.debug('rejected_file_names {}'.format(len(rejected_file_names)))
        rejected_file_names = [item for sublist in rejected_file_names for item in sublist]
        log.debug('rejected_file_names II {}'.format(len(rejected_file_names)))

        with open(args.rejectedFileNamesToFile, 'w') as nameListFile:
            nameListFile.write('\n'.join(rejected_file_names))
